<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Firebase Cloud Messaging接入文档]]></title>
      <url>%2F2017%2F03%2F20%2FFirebase%20Cloud%20Messaging%E6%8E%A5%E5%85%A5%E6%96%87%E6%A1%A3%2F</url>
      <content type="text"><![CDATA[一、Firebase Cloud Messaging简介参考文档：https://firebase.google.com/docs/cloud-messaging/ 1、引入说起Firebase Cloud Messaging（简称FCM），可能多数人都不知道，但是说起GCM（Google Cloud Messaging）想必安卓开发人员都了解，虽然目前国内的安卓设备都阉割了谷歌服务导致GCM并不能正常使用，但是GCM的知名度还是有的。 2、工作原理即使关闭了苹果手机的软件，手机依然可以收到软件推送的消息，原因就是该消息是从软件的服务器经由苹果的服务器转发到苹果手机上的，而GCM的作用跟该苹果的推送原理类似，软件服务器将消息交给谷歌服务器，谷歌的服务器将消息推送到安卓设备上，可以极大的减少无用软件的唤醒，降低手机耗电量。 3、现状由于谷歌在国内被屏蔽访问，国内的大部分手机都阉割了谷歌服务，这就导致了GCM不可用，各大厂商都想方设法保持自己的软件在安卓设备上处于活动状态，便于及时将各种消息推送到安卓设备上，导致人们对安卓的印象就是卡顿和耗电，这跟GCM的不可用有极大关系。 由于公司业务需要，要做国外运营的软件，所以就需要接入GCM，上谷歌查询文档，发现官方已经不再推荐开发者使用GCM了，而推荐更为强大的FCM，可以认为FCM是GCM的改进版或者加强版。 二、接入准备工作1、开发设备装有谷歌服务器的安卓手机一台 2、开发环境Android Studio 3、控制台设置（1）、创建应用打开Firebase控制台：https://console.firebase.google.com/点击新建项目 （2）、填写项目名称在弹出的窗口填写项目名称，然后点击创建项目 （3）、集成Firebase到安卓在Overview选项中点击将Firebase添加到您的Android应用 （4）、填写包名和sha1在弹出的窗口中输入项目的包名和sha1，然后点击添加应用 （5）、下载google-services.json创建成功后点击Download google-services.json，然后将项目切换到Project视图，将下载的文件放入到app的根目录 PS：切记，添加的sha1如果是debug版，那么正式版的sha1也需要添加进去。点击Overview后面的设置按钮，再选择项目设置，找到常规选项卡，在下方继续添加sha1即可，保存后记得重新下载google-services.json并放到app的根目录中 三、Android端集成FCM参考文档：https://firebase.google.com/docs/cloud-messaging/android/client 1、修改gradle文件（1）、项目级build.gradle在项目级的build.gradle文件中的dependencies节点中添加下面代码 1classpath 'com.google.gms:google-services:3.0.0' （2）、应用级build.gradle在应用级的build.gradle文件中添加依赖 1compile 'com.google.firebase:firebase-messaging:10.0.2' 将下面的代码放到文件的最后一行 1apply plugin: 'com.google.gms.google-services' 2、创建MyFirebaseInstanceIDService在项目中新建MyFirebaseInstanceIDService，继承FirebaseInstanceIdService，并重写下面的方法 123456@Overridepublic void onTokenRefresh() &#123; super.onTokenRefresh(); String refreshedToken = FirebaseInstanceId.getInstance().getToken(); Log.d(TAG, "Refreshed token: " + refreshedToken);&#125; 在清单文件中注册Service 12345&lt;service android:name=".MyFirebaseInstanceIDService"&gt; &lt;intent-filter&gt; &lt;action android:name="com.google.firebase.INSTANCE_ID_EVENT"/&gt; &lt;/intent-filter&gt;&lt;/service&gt; 3、MyFirebaseMessagingService新建MyFirebaseMessagingService，继承FirebaseMessagingService，重写下面方法 12345678910111213141516@Overridepublic void onMessageReceived(RemoteMessage remoteMessage) &#123; super.onMessageReceived(remoteMessage); Log.d(TAG, "From: " + remoteMessage.getFrom()); // Check if message contains a data payload. if (remoteMessage.getData().size() &gt; 0) &#123; Log.d(TAG, "Message data payload: " + remoteMessage.getData()); &#125; // Check if message contains a notification payload. if (remoteMessage.getNotification() != null) &#123; Log.d(TAG, "Message Notification Body: " + remoteMessage.getNotification().getBody()); &#125;&#125; 在清单文件中注册123456&lt;service android:name=".MyFirebaseMessagingService"&gt; &lt;intent-filter&gt; &lt;action android:name="com.google.firebase.MESSAGING_EVENT"/&gt; &lt;/intent-filter&gt;&lt;/service&gt; 4、获取token在项目中，可以通过下面代码获取设备的token，并将token发送到服务器，便于服务器进行指定设备的消息推送 1FirebaseInstanceId.getInstance().getToken(); 5、设置图标和背景色在清单文件中添加下面代码，可以分别设置通知的图标和图标的背景色 123456&lt;meta-data android:name="com.google.firebase.messaging.default_notification_icon" android:resource="@drawable/icon_logo" /&gt;&lt;meta-data android:name="com.google.firebase.messaging.default_notification_color" android:resource="@color/colorPrimary" /&gt; 四、发送消息1、控制台发送消息在控制台左侧选择Notifications，然后点击写新消息，就可以向指定设备或全部设备发送消息了 2、通过发送post请求发送消息（1）、请求地址请求的地址为：https://fcm.googleapis.com/fcm/send （2）、请求头部http头部必须包含两部分Content-Type:application/jsonAuthorization:key=YOUR_SERVER_KEY其中serverkey可以在控制台的设置–项目设置–云消息传递–服务器密钥中获取 （3）、发送内容如果发送通知消息，则发送的内容类似与下面的代码 123456&#123; "notification": &#123; "title": "Portugal vs. Denmark", "text": "5 to 1" &#125;, "to" : "bk3RNwTe3H0:CI2k_HHwgIpoDKCIZvvDMExUdFQ3P1..."&#125; 其中to的值是设备的token 更多参数设置可以参考：https://firebase.google.com/docs/cloud-messaging/concept-options?hl=zh-cn#notifications]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[升级Https的那些事]]></title>
      <url>%2F2017%2F02%2F16%2F%E5%8D%87%E7%BA%A7Https%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
      <content type="text"><![CDATA[一、为什么升级Https1、苹果iOS强制开启ATS标准苹果宣布2017年1月1日起，所有提交到App Store 的App必须强制开启ATS安全标准(App Transport Security)，所有连接必须使用Https加密。（后延期了，具体日期还没确定，详情见：https://developer.apple.com/news/?id=12212016b） 2、Http协议无法加密数据Http明文协议的缺陷，是导致数据泄露、数据篡改、流量劫持、钓鱼攻击等安全问题的重要原因。Http协议无法加密数据，所有通信数据都在网络中明文“裸奔”，通过网络的嗅探设备及一些技术手段，就可还原Http报文内容。 二、证书申请1、货比三家（1）、赛门铁克优点：国际大厂，信誉保证缺点：证书价格太贵，购买售后全为英文，不方便 （2）、沃通优点：价格公道，国内多家网站使用，中文网站及客服缺点：最便宜的证书不是沃通直接颁发 （3）、免费SSL优点：免费，申请快缺点：不适合企业使用 2、购买综合考虑，个人可以考虑申请免费SSL，企业申请沃通的SSL 购买地址：http://www.wosign.com/price.htm 三、服务器配置证书（基于Wildfly（Jboss）） 参考文档：http://www.cnblogs.com/maximo/p/5775627.html 1、配置证书找到Wildfly的配置文件路径 wildfly9\standalone\configuration\standalone.xml，在应用域加入keystore信息，并将证书（juemuren.com.jks）复制到同目录下，如下： 1234567891011121314151617&lt;security-realm name="ApplicationRealm"&gt; &lt;authentication&gt; &lt;local default-user="$local" allowed-users="*" skip-group-loading="true"/&gt; &lt;properties path="application-users.properties" relative-to="jboss.server.config.dir"/&gt; &lt;/authentication&gt; &lt;authorization&gt; &lt;properties path="application-roles.properties" relative-to="jboss.server.config.dir"/&gt; &lt;/authorization&gt;&lt;/security-realm&gt;&lt;!--以下为新增--&gt;&lt;security-realm name="SslRealm"&gt; &lt;server-identities&gt; &lt;ssl&gt; &lt;keystore path="juemuren.com.jks" relative-to="jboss.server.config.dir" keystore-password="123456"/&gt; &lt;/ssl&gt; &lt;/server-identities&gt;&lt;/security-realm&gt; 2、配置https监听打开wildfly9\standalone\configuration\standalone.xml，在应用域加入123456789101112131415161718192021222324&lt;subsystem xmlns="urn:jboss:domain:undertow:3.0"&gt; &lt;buffer-cache name="default"/&gt; &lt;server name="default-server"&gt; &lt;http-listener name="default" socket-binding="http" redirect-socket="https"/&gt; &lt;!--以下为新增--&gt; &lt;https-listener name="https" security-realm="SslRealm" socket-binding="https"/&gt; &lt;host name="default-host" alias="localhost"&gt; &lt;location name="/" handler="welcome-content"/&gt; &lt;filter-ref name="server-header"/&gt; &lt;filter-ref name="x-powered-by-header"/&gt; &lt;/host&gt; &lt;/server&gt; &lt;servlet-container name="default"&gt; &lt;jsp-config development="true"/&gt; &lt;/servlet-container&gt; &lt;handlers&gt; &lt;file name="welcome-content" path="$&#123;jboss.home.dir&#125;/welcome-content"/&gt; &lt;/handlers&gt; &lt;filters&gt; &lt;response-header name="server-header" header-name="Server" header-value="WildFly/10"/&gt; &lt;response-header name="x-powered-by-header" header-name="X-Powered-By" header-value="Undertow/1"/&gt; &lt;/filters&gt;&lt;/subsystem&gt; 3、设置http跳转https（1）、全局自动监听修改wildfly9/standalone/deployments/juemuren.com.war/WEB-INF\web.xml 123456789&lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;juemuren.com&lt;/web-resource-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/web-resource-collection&gt; &lt;user-data-constraint&gt; &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt; &lt;/user-data-constraint&gt;&lt;/security-constraint&gt; （2）、JS监听在对应的页面html最开始添加下面的js代码： 1234567&lt;script type="type/javascript"&gt; var url=window.location.href; if (url.indexOf("https")&lt;0) &#123; url=url.replace("http", "https"); window.location.replace(url); &#125;;&lt;/script&gt; 四、APP配置（安卓端） 参考文档：http://www.cnblogs.com/punkisnotdead/p/4788199.html 1、Volley启用https支持（1）、修改Volley源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212import android.content.Context;import android.content.pm.PackageInfo;import android.content.pm.PackageManager.NameNotFoundException;import android.net.http.AndroidHttpClient;import android.os.Build;import android.util.Log;import com.android.volley.Network;import com.android.volley.RequestQueue;import com.android.volley.toolbox.BasicNetwork;import com.android.volley.toolbox.DiskBasedCache;import com.android.volley.toolbox.HttpClientStack;import com.android.volley.toolbox.HttpStack;import com.android.volley.toolbox.HurlStack;import org.apache.http.client.HttpClient;import org.apache.http.conn.scheme.PlainSocketFactory;import org.apache.http.conn.scheme.Scheme;import org.apache.http.conn.scheme.SchemeRegistry;import org.apache.http.impl.client.DefaultHttpClient;import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;import org.apache.http.params.BasicHttpParams;import org.apache.http.params.HttpParams;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.security.KeyManagementException;import java.security.KeyStore;import java.security.KeyStoreException;import java.security.NoSuchAlgorithmException;import java.security.UnrecoverableKeyException;import java.security.cert.Certificate;import java.security.cert.CertificateException;import java.security.cert.CertificateFactory;import javax.net.ssl.SSLContext;import javax.net.ssl.SSLSocketFactory;import javax.net.ssl.TrustManagerFactory;public class Volley &#123; /** * Default on-disk cache directory. */ private static final String DEFAULT_CACHE_DIR = "volley"; private static BasicNetwork network; private static RequestQueue queue; private Context mContext; /** * Creates a default instance of the worker pool and calls &#123;@link RequestQueue#start()&#125; on it. * * @param context A &#123;@link Context&#125; to use for creating the cache dir. * @param stack An &#123;@link HttpStack&#125; to use for the network, or null for default. * @return A started &#123;@link RequestQueue&#125; instance. */ public static RequestQueue newRequestQueue(Context context, HttpStack stack, boolean selfSignedCertificate, int rawId) &#123; File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR); String userAgent = "volley/0"; try &#123; String packageName = context.getPackageName(); PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0); userAgent = packageName + "/" + info.versionCode; &#125; catch (NameNotFoundException e) &#123; &#125; if (stack == null) &#123; if (Build.VERSION.SDK_INT &gt;= 9) &#123; if (selfSignedCertificate) &#123; stack = new HurlStack(null, buildSSLSocketFactory(context, rawId)); &#125; else &#123; stack = new HurlStack(); &#125; &#125; else &#123; // Prior to Gingerbread, HttpUrlConnection was unreliable. // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html if (selfSignedCertificate) stack = new HttpClientStack(getHttpClient(context, rawId)); else &#123; stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent)); &#125; &#125; &#125; Network network = new BasicNetwork(stack); RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network); queue.start(); return queue; &#125; /** * Creates a default instance of the worker pool and calls &#123;@link RequestQueue#start()&#125; on it. * * @param context A &#123;@link Context&#125; to use for creating the cache dir. * @return A started &#123;@link RequestQueue&#125; instance. */ public static RequestQueue newRequestQueue(Context context) &#123; return newRequestQueue(context, null, false, 0); &#125; private static SSLSocketFactory buildSSLSocketFactory(Context context, int certRawResId) &#123; KeyStore keyStore = null; try &#123; keyStore = buildKeyStore(context, certRawResId); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm(); TrustManagerFactory tmf = null; try &#123; tmf = TrustManagerFactory.getInstance(tmfAlgorithm); tmf.init(keyStore); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; SSLContext sslContext = null; try &#123; sslContext = SSLContext.getInstance("TLS"); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; try &#123; sslContext.init(null, tmf.getTrustManagers(), null); &#125; catch (KeyManagementException e) &#123; e.printStackTrace(); &#125; return sslContext.getSocketFactory(); &#125; private static HttpClient getHttpClient(Context context, int certRawResId) &#123; KeyStore keyStore = null; try &#123; keyStore = buildKeyStore(context, certRawResId); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if (keyStore != null) &#123; &#125; org.apache.http.conn.ssl.SSLSocketFactory sslSocketFactory = null; try &#123; sslSocketFactory = new org.apache.http.conn.ssl.SSLSocketFactory(keyStore); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (KeyManagementException e) &#123; e.printStackTrace(); &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; catch (UnrecoverableKeyException e) &#123; e.printStackTrace(); &#125; HttpParams params = new BasicHttpParams(); SchemeRegistry schemeRegistry = new SchemeRegistry(); schemeRegistry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80)); schemeRegistry.register(new Scheme("https", sslSocketFactory, 443)); ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(params, schemeRegistry); return new DefaultHttpClient(cm, params); &#125; private static KeyStore buildKeyStore(Context context, int certRawResId) throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException &#123; String keyStoreType = KeyStore.getDefaultType(); KeyStore keyStore = KeyStore.getInstance(keyStoreType); keyStore.load(null, null); Certificate cert = readCert(context, certRawResId); keyStore.setCertificateEntry("ca", cert); return keyStore; &#125; private static Certificate readCert(Context context, int certResourceID) &#123; InputStream inputStream = context.getResources().openRawResource(certResourceID); Certificate ca = null; CertificateFactory cf = null; try &#123; cf = CertificateFactory.getInstance("X.509"); ca = cf.generateCertificate(inputStream); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; return ca; &#125;&#125; （2）、使用for other server的证书（juemuren.crt），将证书放在raw文件夹下，RequestQueue按下面获取1RequestQueue mQueue= Volley.newRequestQueue(context, null, true, R.raw.juemuren); （3）、StringRequest延长超时时长12StringRequest request=new StringRequest();request.setRetryPolicy(new DefaultRetryPolicy(30 * 1000, 2, 1.0f)) 2、兼容旧版本新版本的接口全换成https的，要想兼容旧版本，服务器配置http跳转https的监听可以设置为js版本的监听。 完成以上设置之后，就可以愉快的用Https访问网站了，enjoy~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[支付宝APP支付集成文档]]></title>
      <url>%2F2017%2F01%2F21%2F%E6%94%AF%E4%BB%98%E5%AE%9DAPP%E6%94%AF%E4%BB%98%E9%9B%86%E6%88%90%E6%96%87%E6%A1%A3%2F</url>
      <content type="text"><![CDATA[一、开发前提 适用于商家在App应用中集成支付宝支付功能。商家APP调用支付宝提供的SDK调用支付宝客户端内的支付模块，商家APP会跳转到支付宝中完成支付，支付完后跳回到商家APP内，最后展示支付结果。 本文档旨在指导开发者快速集成支付宝APP支付，包括开签约APP支付、服务器配置以及安卓端配置。 1、签约APP支付APP要想接入支付宝支付功能需要签约支付宝的APP支付，签约要符合申请的条件，根据操作提示完成申请，等待审核通过即可 签约链接：https://b.alipay.com/signing/productScene.htm?sceneId=wysk&amp;navKey=wysk 如图： 2、创建应用并获取APPID然后创建应用，创建成功后即可获取到APPID创建应用地址：https://openhome.alipay.com/platform/appCreate.htm 如图： 3、添加功能创建应用之后，还有给应用添加APP支付功能 如图： 勾选APP支付，确定即可 4、上线应用根据提示提交审核，等待审核通过即可，注意：测试APP支付必须上线应用，因为沙箱测试不能测试APP支付，可能出现ALI40247错误，见链接：https://openclub.alipay.com/read.php?tid=250&amp;fid=2https://support.open.alipay.com/support/hotProblemDetail.htm?spm=a219a.7386797.0.0.BZfVkv&amp;id=259972 点击上线，按照提示完成操作即可，如图： 5、配置密钥参考链接：https://doc.open.alipay.com/doc2/detail.htm?treeId=200&amp;articleId=105310&amp;docType=1 点击这里下载一键生成RSA密钥工具 生成之后，Java开发找到pkcs8格式的私钥签名，去除头尾、换行和空格，作为开发者私钥 将公钥去除头尾、换行和空格，填入如图所示的地方 填写之后，可以验证公钥的正确性， 根据图示操作即可： 6、了解业务流程 二、服务器配置参考文档：https://doc.open.alipay.com/doc2/detail?treeId=54&amp;articleId=103419&amp;docType=1 1、下载SDK服务器SDK有不同的开发语言版本，下载相应的版本，如图： 2、引入jar包下面以java为例 集成支付宝接口需要引入的文件是：alipay-sdk-java*.jarcommons-logging-1.1.1.jar 若进一步了解代码实现请引入文件：alipay-sdk-java*-source.jarcommons-logging-1.1.1-sources.jar 3、调用示例传入服务器创建订单所需参数参考文档：https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.Q48Wtz&amp;treeId=193&amp;articleId=105465&amp;docType=1 参考事例代码：123456789101112131415161718//实例化客户端AlipayClient client = new DefaultAlipayClient("https://openapi.alipay.com/gateway.do",APP_ID,APP_PRIVATE_KEY,"json","GBK",ALIPAY_PUBLIC_KEY);//实例化具体API对应的request类,类名称和接口名称对应,当前调用接口名称：alipay.trade.app.pay AlipayTradeAppPayRequest request = new AlipayTradeAppPayRequest();//SDK已经封装掉了公共参数，这里只需要传入业务参数//此次只是参数展示，未进行字符串转义，实际情况下请转义request.setBizContent(" &#123; "primary_industry_name":"IT科技/IT软件与服务", "primary_industry_code":"10001/20102", "secondary_industry_code":"10001/20102", "secondary_industry_name":"IT科技/IT软件与服务" &#125;");AlipayTradeAppPayResponse response = client.execute(request); //调用成功，则处理业务逻辑if(response.isSuccess())&#123; //.....&#125; 三、Android端配置参考文档：https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.rSXklx&amp;treeId=193&amp;articleId=105296&amp;docType=1 1、下载SDK并导入下载地址：https://doc.open.alipay.com/doc2/detail.htm?treeId=54&amp;articleId=104509&amp;docType=1下载后导入工程中 2、注册Activity并添加权限123456789101112131415161718&lt;activity android:name="com.alipay.sdk.app.H5PayActivity" android:configChanges="orientation|keyboardHidden|navigation" android:exported="false" android:screenOrientation="behind"&gt;&lt;/activity&gt;&lt;activity android:name="com.alipay.sdk.auth.AuthActivity" android:configChanges="orientation|keyboardHidden|navigation" android:exported="false" android:screenOrientation="behind"&gt;&lt;/activity&gt;&lt;uses-permission android:name="android.permission.INTERNET"/&gt;&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt;&lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/&gt;&lt;uses-permission android:name="android.permission.READ_PHONE_STATE"/&gt;&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; 3、添加混淆规则1234567-libraryjars libs/alipaySDK-20150602.jar-keep class com.alipay.android.app.IAlixPay&#123;*;&#125;-keep class com.alipay.android.app.IAlixPay$Stub&#123;*;&#125;-keep class com.alipay.android.app.IRemoteServiceCallback&#123;*;&#125;-keep class com.alipay.android.app.IRemoteServiceCallback$Stub&#123;*;&#125;-keep class com.alipay.sdk.app.PayTask&#123; public *;&#125;-keep class com.alipay.sdk.app.AuthTask&#123; public *;&#125; 4、调用支付接口需要在新线程中调用支付接口（可参考alipay_demo实现）获取PayTask支付对象调用支付（支付行为需要在独立的非ui线程中执行），代码示例： 123456789101112131415final String orderInfo = info; // 订单信息Runnable payRunnable = new Runnable() &#123; @Override public void run() &#123; PayTask alipay = new PayTask(DemoActivity.this); String result = alipay.payV2(orderInfo,true); Message msg = new Message(); msg.what = SDK_PAY_FLAG; msg.obj = result; mHandler.sendMessage(msg); &#125;&#125;; // 必须异步调用Thread payThread = new Thread(payRunnable);payThread.start(); 5、支付结果获取和处理（1）、同步返回商户应用客户端通过当前调用支付的Activity的Handler对象，通过它的回调函数获取支付结果。（可参考alipay_demo实现） 123456private Handler mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; Result result = new Result((String) msg.obj); Toast.makeText(DemoActivity.this, result.getResult(), Toast.LENGTH_LONG).show(); &#125;;&#125;; （2）、异步通知商户需要提供一个http协议的接口，包含在请求支付的入参中，其key对应notify_url。支付宝服务器在支付完成后，会以POST方式调用notify_url传输数据。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OpenStreetMap开发文档]]></title>
      <url>%2F2017%2F01%2F13%2FOpenStreetMap%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3%2F</url>
      <content type="text"><![CDATA[前言 OpenStreetMap社区是一个由地图制作爱好者组成的社区，这些爱好者提供并维护世界各地关于道路、小道、咖啡馆、铁路车站等各种各样的数据。OpenStreetMap开源项目可以让程序开发更加灵活，图源更加丰富，例如可以使用谷歌地图，以解决国内无法使用谷歌服务的尴尬。国内户外导航软件，例如：行者、户外帮和小狼信标都使用了OpenStreetMap。 Android版OpenStreetMap的github地址：osmdroid5.2地图缓存的是瓦片，5.4之后地图缓存到数据库 一、环境配置1、Gradle中添加依赖1compile 'org.osmdroid:osmdroid-android:5.2@aar' 2、权限配置123&lt;uses-permission android:name="android.permission.INTERNET"/&gt;&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt; 提示：编译版本为23或以上版本，要注意动态获取读写存储空间权限，否则地图可能不显示 二、基础MapView使用1、使用内置地图源（1）、在布局文件中添加MapView控件，在代码中找到控件并设置图源1234&lt;org.osmdroid.views.MapView android:id="@+id/mapView" android:layout_width="match_parent" android:layout_height="match_parent"/&gt; 12MapView mMapView= (MapView) findViewById(R.id.mapView);mMapView.setTileSource(TileSourceFactory.CYCLEMAP);//（OCM等高）若不设置，则默认使用的是MAPNIK（OSM街道） （2）、直接在代码中new MapView，然后设置图源，并将MapView添加到父布局中12MapView mMapView=new MapView(this);mMapView.setTileSource(TileSourceFactory.MAPNIK); 2、设置其他地图源（1）、谷歌图源a、新建一个谷歌图源类，继承OnlineTileSourceBase123456789101112131415161718public class GoogleMapsTileSource extends OnlineTileSourceBase &#123; /** * @param aName a human-friendly name for this tile source 自定图源义名字，会在手机外部存储中新建以该名字命名的文件夹，瓦片存储在其中 * @param aZoomMinLevel the minimum zoom level this tile source can provide 最小缩放级别 * @param aZoomMaxLevel the maximum zoom level this tile source can provide 最大缩放级别 * @param aTileSizePixels the tile size in pixels this tile source provides 瓦片质量 （256） * @param aImageFilenameEnding the file name extension used when constructing the filename 瓦片格式（jpg[有损压缩率高、不透明]、png[无损、透明]） * @param aBaseUrl the base url(s) of the tile server used when constructing the url to download the tiles 下载瓦片的链接（前缀） */ public GoogleMapsTileSource(String aName, int aZoomMinLevel, int aZoomMaxLevel, int aTileSizePixels, String aImageFilenameEnding, String[] aBaseUrl) &#123; super(aName, aZoomMinLevel, aZoomMaxLevel, aTileSizePixels, aImageFilenameEnding, aBaseUrl); &#125; @Override public String getTileURLString(MapTile aTile) &#123; return getBaseUrl() + "&amp;x=" + aTile.getX() + "&amp;y=" + aTile.getY() + "&amp;z=" + aTile.getZoomLevel(); &#125;&#125; b、new一个谷歌图源对象，并设置MapView图源123456String str1 = "http://mt0.google.cn/vt/lyrs=m&amp;hl=zh-CN&amp;gl=cn&amp;scale=2";String str2 = "http://mt1.google.cn/vt/lyrs=m&amp;hl=zh-CN&amp;gl=cn&amp;scale=2";String str3 = "http://mt2.google.cn/vt/lyrs=m&amp;hl=zh-CN&amp;gl=cn&amp;scale=2";String str4 = "http://mt3.google.cn/vt/lyrs=m&amp;hl=zh-CN&amp;gl=cn&amp;scale=2";GoogleMapsTileSource googleMapsTileSource = new GoogleMapsTileSource("GoogleNormal", 2, 19, 256, ".png", new String[]&#123;str1, str2, str3, str4&#125;);mMapView.setTileSource(googleMapsTileSource); （2）、必应等图源，使用方法类似于谷歌图源 参考文档：http://blog.csdn.net/youngkingyj/article/details/23365849 3、让瓦片适应不同像素密度 默认地图显示的字体小，图片像素高，可设置以下代码，使地图适应不同像素密度，更美观 1mMapView.setTilesScaledToDpi(true); 4、添加指南针123CompassOverlay mCompassOverlay = new CompassOverlay(MainActivity.this, new InternalCompassOrientationProvider(MainActivity.this), mMapView);mMapView.getOverlays().add(mCompassOverlay);mCompassOverlay.enableCompass(); 按此方法添加指南针之后，部分手机仍不显示指南针，原因未知 5、添加比例尺12ScaleBarOverlay mScaleBarOverlay = new ScaleBarOverlay(mMapView);mMapView.getOverlays().add(mScaleBarOverlay); 添加上面代码后，比例尺显示在左上角，而且不美观，可以继续添加下面代码，使比例尺显示在左下角 123mScaleBarOverlay.setAlignBottom(true);mScaleBarOverlay.setLineWidth(1 * (getResources().getDisplayMetrics()).density);mScaleBarOverlay.setMaxLength(0.85f); 6、设置地图中心123GeoPoint geopoint = new GeoPoint(39.986250, 116.400025);MapController mMapController= (MapController) mMapView.getController();//获取MapView控制器mMapController.setCenter(geopoint);//设置地图中心 7、其他设置（1）、设置缩放界别1mMapController.setZoom(15);//设置缩放级别 （2）、设置缩放按钮可见1mMapView.setBuiltInZoomControls(true);//设置缩放按钮可见 （3）、设置多指触控可用1mMapView.setMultiTouchControls(true);//设置多指触控可用 （4）、关闭硬件加速1mMapView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);//关闭硬件加速(绘制轨迹时需要) （5）、地图可旋转123RotationGestureOverlay mRotationGestureOverlay = new RotationGestureOverlay(this, mMapView);mRotationGestureOverlay.setEnabled(true);mMapView.getOverlays().add(mRotationGestureOverlay); 三、进阶使用1、自定义瓦片缓存位置默认会在外部存储中新建名为somdroid的文件夹，瓦片就存储在其中。 自定义缓存位置就是在外部存储中创建一个文件夹，然后设置为瓦片的缓存位置，放在MapView初始化之前例如： 1234567891011121314151617181920File dir = new File(Environment.getExternalStorageDirectory(), "AAA");//新建文件夹if (dir.exists()) &#123; File nomedia = new File(dir.getAbsoluteFile() + "/.nomedia"); if (!nomedia.exists()) &#123; try &#123; nomedia.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; else &#123; dir.mkdirs(); File file = dir.getAbsoluteFile(); try &#123; new File(file + "/.nomedia").createNewFile(); &#125; catch (Exception ex) &#123; android.util.Log.e(IMapView.LOGTAG, "unable to create a nomedia file. downloaded tiles may be visible to the gallery.", ex); &#125;&#125;OpenStreetMapTileProviderConstants.setCachePath(dir + "");//设置MapView的缓存路径 2、添加Marker1234567Marker marker = new Marker(mMapView);marker.setIcon(getResources().getDrawable(R.mipmap.ic_launcher));//设置图标marker.setPosition(geopoint);//设置位置marker.setAnchor(0.5f, 0.5f);//设置偏移量marker.setTitle("我是Titile");//设置标题marker.setSubDescription("我是SubDescription");//设置说明mMapView.getOverlays().add(marker);//添加marker到MapView 点击Marker之后会出现气泡，显示title和subDescription 3、连线1234PathOverlay pathOverlay = new PathOverlay(Color.BLUE, 10, this);pathOverlay.addPoint(new GeoPoint(39.986250, 116.400025));pathOverlay.addPoint(new GeoPoint(39.886250, 116.300025));mMapView.getOverlays().add(pathOverlay); 连线时务必关闭硬件加速，否则可能显示不出来连的线 4、离线地图下载123456789CacheManager cacheManager = new CacheManager(mMapView);//获取下载器 BoundingBoxE6 boundingBoxE6 = mMapView.getBoundingBox();//获取当前区域 int tileNum = cacheManager.possibleTilesInArea(boundingBoxE6, 8, 16);//计算当前区域8-16级的瓦片数量 cacheManager.downloadAreaAsync(this, boundingBoxE6, 8, 16, new CacheManager.CacheManagerCallback() &#123;//下载 @Override public void onTaskComplete() &#123; //下载完成后的回调 &#125; &#125;); 下载时会有进度框，若点击进度框以外的区域会取消下载，若想修改逻辑可参考CacheManager，自定义一个CacheManage]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[文件管理器--Solid Explorer2]]></title>
      <url>%2F2017%2F01%2F05%2F%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8--Solid%20Explorer2%2F</url>
      <content type="text"><![CDATA[一、Solid Explorer2简介Solid Explorer2是一款Material风格的文件管理器，是安卓手机必备的一款文件管理软件，它支持但不限于以下功能： 双面板可同时进行双重文件管理 丰富的界面选项：图标，配色方案及主题 支持面板之间的拖放操作 支持 FTP，SFTP， WebDav 以及 SMB / CIFS 支持读取并解压ZIP，7ZIP，RAR和TAR文件，支持加密压缩文件 能够创建受密码保护的ZIP和7ZIP文件 云服务管理器，支持：Dropbox, Box, OneDrive, Google Drive, Sugarsync, Copy, Mediafire, Owncloud, Yandex, Mega 在取得Root权限的设备上拥有更加完整的功能 可扩展性：支持从 Play 商店下载独立插件以获取更多功能 索引搜索能让你在几秒钟之内找到你的文件 详细的存储空间使用情况统计和文件信息 实用功能：隐藏不需要的文件夹，FTP服务器（插件），书签，支持 Chromecast，媒体浏览器.. 下载地址：酷安 Google Play（需梯子） PS：默认试用期为14天，不翻墙不提示试用到期 二、功能详解1、双面板Solid Explorer2默认打开双面板，竖屏状态下直接左右滑动即可切换面板；横屏状态下直接显示双面板。 双面板可以极大提高操作效率，例如：在A面板复制了一个文件，直接切换到B面板，然后粘贴即可。 2、导出安装包打开侧面板，点击应用 然后选择用户应用 长按选中一个应用，点击右上角菜单 选择分享，即可使用QQ等工具分享出去，选择Save to即可保存到本地目录。 3、云服务管理器点击右下角加号，选择新建云连接 选择想要连接的云服务，根据操作步骤即可完成连接 4、FTP插件首先安装FTP插件下载地址：酷安 Google Play（需梯子） 安装之后保证手机和电脑处于一个局域网，然后打开侧面板，找到FTP服务器并打开 点击开启，在电脑上输入显示的ip即可访问手机的目录了。 更多功能等待你的发掘！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[微信支付集成文档]]></title>
      <url>%2F2016%2F12%2F28%2F%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E9%9B%86%E6%88%90%E6%96%87%E6%A1%A3%2F</url>
      <content type="text"><![CDATA[一、开发前提 APP支付又称移动端支付，是商户通过在移动端应用APP中集成开放SDK调起微信支付模块完成支付的模式。 本文档旨在指导开发者快速集成微信APP支付，包括开发者帐号申请、服务器配置以及安卓端配置。 1、开发者资质认证登录微信开放平台：https://open.weixin.qq.com如图：在帐号中心里，选择开发者资质认证，根据申请引导进行申请，等待审核通过即可 2、创建应用如图：在管理中心里，选择移动应用，点击创建移动应用 创建应用时要求填写应用签名和应用包名，应用签名可以通过软件查看：下载地址，包名可以查看AndroidManifest.xml中声明的package值 填写各项信息之后，等待审核通过，即可获得如下权限： 3、申请开通微信支付应用审核通过后若想获取微信支付能力，需要申请开通微信支付功能，根据申请引导申请即可 4、了解支付流程以下是交互时序图，统一下单API、支付结果通知API和查询订单API等都涉及签名过程，调用都必须在商户服务器端完成。 二、服务器配置 参考文档：https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_1 1、统一下单商户系统先调用该接口在微信支付服务后台生成预支付交易单，返回正确的预支付交易回话标识后再在APP里面调起支付。 接口地址：https://api.mch.weixin.qq.com/pay/unifiedorder 必传参数： 字段名 变量名 必填 类型 示例值 描述 应用ID appid 是 String(32) wxd678efh567hg6787 微信开放平台审核通过的应用APPID 商户号 mch_id 是 String(32) 1230000109 微信支付分配的商户号 随机字符串 nonce_str 是 String(32) 5K8264ILTKCH16CQ2502SI8ZNMTM67VS 随机字符串，不长于32位。推荐随机数生成算法 签名 sign 是 String(32) C380BEC2BFD727A4B6845133519F3AD6 签名，详见签名生成算法 商品描述 body 是 String(128) 腾讯充值中心-QQ会员充值 商品描述交易字段格式根据不同的应用场景按照以下格式：应用市场上的APP名字-实际商品名称，天天爱消除-游戏充值。 商户订单号 out_trade_no 是 String(32) 20150806125346 商户系统内部的订单号,32个字符内、可包含字母, 其他说明见商户订单号 总金额 total_fee 是 Int 888 订单总金额，单位为分，详见支付金额 终端IP spbill_create_ip 是 String(16) 123.12.12.123 用户端实际ip 通知地址 notify_url 是 String(256) http://www.weixin.qq.com/wxpay/pay.php 接收微信支付异步通知回调地址，通知url必须为直接可访问的url，不能携带参数。 交易类型 trade_type 是 String(16) APP 支付类型 2、在线验证签名微信提供了在线验证签名，以检测开发者调用微信公众平台开发者API时发送的请求参数是否正确 在线验证地址：https://pay.weixin.qq.com/wiki/tools/signverify/ 如图：填写各项参数，点击生成签名，然后将生成的#4.最终的提交xml的内容提交给统一支付下单接口即可。 3、再次验签商户系统调用统一下单接口后在微信支付服务后台生成预支付交易订（prepay_id），返回正确的预支付交易回话标识后再将APP端需要的参数进行签名，然后返回给APP，再在APP里面调起支付。 统一下单接口返回结果如下： 1234567891011&lt;xml&gt; &lt;return_code&gt;&lt;![CDATA[SUCCESS]]&gt;&lt;/return_code&gt; &lt;return_msg&gt;&lt;![CDATA[OK]]&gt;&lt;/return_msg&gt; &lt;appid&gt;&lt;![CDATA[wxdf5a5e8166b65d8e]]&gt;&lt;/appid&gt; &lt;mch_id&gt;&lt;![CDATA[1413719303]]&gt;&lt;/mch_id&gt; &lt;nonce_str&gt;&lt;![CDATA[cCKl1CPUKbc1Viu1]]&gt;&lt;/nonce_str&gt; &lt;sign&gt;&lt;![CDATA[A457DA342972CE8EB86C9BFA46BDFC86]]&gt;&lt;/sign&gt; &lt;result_code&gt;&lt;![CDATA[SUCCESS]]&gt;&lt;/result_code&gt; &lt;prepay_id&gt;&lt;![CDATA[wx20161123112638700583976e0487596811]]&gt;&lt;/prepay_id&gt; &lt;trade_type&gt;&lt;![CDATA[APP]]&gt;&lt;/trade_type&gt; &lt;/xml&gt; 然后，将APP端需要的参数再次签名，然后将参数和签名返回给APP端如图，签名的参数至少为以下几个：（appid、partnerid、noncestr、package、prepayid、timestamp） 4、注意事项调用统一下单接口需要验签，收到返回结果之后，还需要将APP调起支付所需要的参数再次验签，然后再返回给APP端，在APP端调起支付即可。 三、Android端配置 参考文档：https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=8_5 1、注册APPID商户APP工程中引入微信JAR包，调用API前，需要先向微信注册您的APPID，代码如下： 123IWXAPI msgApi;msgApi = WXAPIFactory.createWXAPI(this, null);msgApi.registerApp("wxdf5a5e8166b65d8e");// 将该app注册到微信 经测试：以下组合均能注册成功 12msgApi = WXAPIFactory.createWXAPI(this, "wxdf5a5e8166b65d8e", true);msgApi.registerApp("wxdf5a5e8166b65d8e"); 12msgApi = WXAPIFactory.createWXAPI(this, "wxdf5a5e8166b65d8e", false);msgApi.registerApp("wxdf5a5e8166b65d8e"); 12msgApi = WXAPIFactory.createWXAPI(this, "wxdf5a5e8166b65d8e");msgApi.registerApp("wxdf5a5e8166b65d8e"); 2、调起支付商户服务器生成支付订单，先调用统一下单接口生成预付单，获取到prepay_id后将参数再次签名传输给APP发起支付。以下是调起微信支付的关键代码： 12345678910//msgApi，不用重新声明，使用注册时的就行PayReq request = new PayReq();request.appId = "wxdf5a5e8166b65d8e";request.partnerId = "1413719303";request.prepayId = "wx2016112309404508902deea40216174377";request.nonceStr = "pFDVAPrK4R5okMYg";request.timeStamp = "1456552292";request.packageValue = "Sign=WXPay";request.sign = "68F28572072B187B5F27E1542BEE05F6";msgApi.sendReq(request); APP端调起支付的参数列表可参考：https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_12 3、支付结果回调参照微信SDK Sample，在net.sourceforge.simcpux.wxapi包路径中实现WXPayEntryActivity类(包名或类名不一致会造成无法回调，例如我的包名是com.juemuren.weixinzhifu，则该类需要放在com.juemuren.weixinzhifu.wxapi中)在manifest文件中注册： 123&lt;activity android:name=".wxapi.WXPayEntryActivity" android:exported="true" android:launchMode="singleTop"/&gt; 在WXPayEntryActivity类中实现onResp函数，支付完成后，微信APP会返回到商户APP并回调onResp函数，开发者需要在该函数中接收通知，判断返回错误码，如果支付成功则去后台查询支付结果再展示用户实际支付结果。注意一定不能以客户端返回作为用户支付的结果，应以服务器端的接收的支付通知或查询API返回的结果为准。代码示例如下： 12345678910@Overridepublic void onResp(BaseResp resp) &#123; if (resp.getType() == ConstantsAPI.COMMAND_PAY_BY_WX) &#123; Log.e("resp.errCode=", resp.errCode + ""); AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setTitle("提示"); builder.setMessage("支付结果" + String.valueOf(resp.errCode)); builder.show(); &#125;&#125; 回调中errCode值列表： 字段名 变量名 必填 类型 示例值 描述 返回状态码 return_code 是 String(16) SUCCESS SUCCESS/FAIL SUCCESS表示商户接收通知成功并校验成功 返回信息 return_msg 否 String(128) OK 返回信息，如非空，为错误原因：签名失败 参数格式校验错误 4、注意事项实际支付结果一定不能以客户端返回作为用户支付的结果，应以服务器端的接收的支付通知或查询API返回的结果为准。 确认debug或者打包运行的程序签名与微信开发平台设置的签名一致（使用下面任意一种方法）：①、可以设置后台的签名为debug包的签名，这样每次直接运行即可，待程序发布之前再将签名修改为正式包的签名②、若使用的正式包的签名，则每次都要打包运行，或者可以在build.gradle中的android标签中添加下面的代码（推荐）： 12345678signingConfigs &#123; debug &#123; storeFile file("正式keystore的路径") storePassword "密码" keyAlias "别名" keyPassword "密码" &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo建站全攻略]]></title>
      <url>%2F2016%2F12%2F20%2FHexo%E5%BB%BA%E7%AB%99%E5%85%A8%E6%94%BB%E7%95%A5%2F</url>
      <content type="text"><![CDATA[一、Hexo简介Hexo 是一个快速、简洁且高效的博客框架，使用 Markdown解析文章，在几秒内，即可利用靓丽的主题生成静态网页。演示博客：https://juemuren4449.github.io官方文档：https://hexo.io/zh-cn/docs参考文档：http://jingyan.baidu.com/article/d8072ac47aca0fec95cefd2d.html 二、搭建流程（Windows）1、准备工作（1）、安装git下载地址：https://git-scm.com/download选择对应的平台，下载到本地，默认安装即可。 （2）、安装node.js下载地址：https://nodejs.org/en推荐下载LTS版，默认安装即可 2、安装hexo在任意位置右键，选择Git Bash Here，然后输入 npm install -g hexo-cli 回车之后，开始安装hexo，安装完成后如下图所示： 3、初始化hexo文件夹（1）、创建文件夹所有的建站文件都会存储在一个文件夹中，所以挑选一个位置，创建一个文件夹，路径和文件夹名字最好是英文。例如我在C:\Users\juemuren目录下创建myweb的文件夹。 （2）、初始化文件夹在myweb文件夹内右键，选择Git Bash Here，然后输入 hexo init 初始化完成后如下图所： 4、安装依赖包在Git Bash中输入 npm install 安装成功后如下图所示： 5、本地运行hexo在Git Bash中输入 hexo generate 再输入 hexo server 完成后在浏览器中打开：http://localhost:4000 打开后如下图所示，此时hexo就运行起来了，如果想停止服务，可以在Git Bash中按Ctrl + C 停止服务。 6、创建仓库在github上创建博客的仓库，创建仓库地址：https://github.com/new例如我的github帐号名为juemuren4449，那么我的Repository的name就必须为juemuren4449.github.io 7、修改配置文件（1）、修改deploy打开C:\Users\juemuren\myweb下的_config.yml文件，搜索deploy，修改为如下格式，其中repository就是刚才创建的仓库地址，需要注意的是每个字段后都有冒号，冒号后有一个英文的空格修改如下所示： 1234deploy: type: git repository: https://github.com/juemuren4449/juemuren4449.github.io.git branch: master （2）、修改URL搜索ULR，将url替换成https://juemuren4449.github.io/ 123# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://juemuren4449.github.io 8、设置SSH keys（1）、生成SHH keys在Git Bash中输入下面的命令，查看是否生成过ssh，如果有则将C:\Users\用户名目录下的.ssh文件夹删除 ls -al ~/.ssh 然后依次输入下面的命令，邮箱为你自己申请github的邮箱 ssh-keygen -t rsa -C “example@qq.com” ssh-agent -s ssh-add ~/.ssh/id_rsa 如果出现Could not open a connection to your authentication agent.则依次输入下面的指令 eval `ssh-agent -s` ssh-add 然后输入下面的命令，复制公钥 clip &lt; ~/.ssh/id_rsa.pub （2）、设置SSH keys点击github的头像，选择Settings 然后依次点击左侧的SSHand GPG keys和右上角的New SSH keytitle可以随意取名，将刚才复制的公钥粘贴到key的文本框中，点击Add SHH key，要求输入密码，输入后即可添加成功。 （3）、测试在Git Bash中输入 ssh -T git@github.com 会出现提示，输入yes，再次按回车，当出现下图所示的文字时，表示测试成功，SSH配置成功！ 9、部署到github上在Git Bash中输入 hexo generate 然后再输入 hexo deploy 如果出现以下错误： 1ERROR Deployer not found: github 就需要安装hexo-deployer-git模块，在Git Bash中输入 npm install hexo-deployer-git –save 安装好之后重新执行 hexo deploy 10、访问博客在浏览器打开：https://juemuren4449.github.io/ ，即可访问基于hexo的博客了！PS：部署之后可能有延迟，请耐心等待。 11、命令简化hexo的命令可以简写，如下： 命令 简写 hexo generate hexo g hexo deploy hexo d hexo server hexo s]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[开始记录]]></title>
      <url>%2F2016%2F12%2F18%2F%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%2F</url>
      <content type="text"><![CDATA[好记性不如烂笔头上学的时候老师就经常说： 要多记，好记性不如烂笔头！ 当时可能没什么感触，但是随着时间的流逝，这句话就越发有道理，所以准备将自己工作和生活中的东西记下来，以便以后查看。 记录内容记录的内容可能会包括一些生活的随笔和Android方面的技术笔记，因为本博客是基于Hexo搭建的，从网上总结了搭建的方法，所以也会包含这方面的内容。 个人认知个人才疏学浅，技术笔记若有疏漏和错误，还希望浏览我博客的朋友们能不吝赐教，互相学习进步！]]></content>
    </entry>

    
  
  
</search>
